# 14. 后端ER图详解

## 📖 这个图讲的是什么？

这个图展示了**后端数据库的实体关系**，就像服务器上的数据库结构图，告诉我们有哪些表，表里有哪些字段，以及表与表之间的关系。

## 🔍 三个主要实体（表）

### 1️⃣ User 实体（用户表）

**作用**：存储用户信息，标识是谁创建了日程

**实体结构**：

| 字段名 | 类型 | 说明 |
|--------|------|------|
| id | BigInteger | 主键，自动生成，唯一标识每个用户 |
| username | CharField | 用户名，必填（如"张三"） |
| email | EmailField | 邮箱地址，必填 |
| password | CharField | 密码（加密存储） |

**简单理解**：这是"用户名单"，记录着所有用户的信息。

**字段详解**：

- **id**：用户的唯一编号，就像身份证号，每个用户都有唯一ID
- **username**：用户名，用于登录和显示（如"张三"）
- **email**：邮箱地址，用于登录和找回密码
- **password**：密码，加密存储，不能直接看到原文

**数据示例**：

```python
User(
    id = 1,
    username = "zhangsan",
    email = "zhangsan@example.com",
    password = "加密后的密码"
)
```

### 2️⃣ Subscription 实体（订阅表）

**作用**：存储订阅的日历源信息，如"中国法定节假日"、"世界纪念日"等

**实体结构**：

| 字段名 | 类型 | 说明 |
|--------|------|------|
| id | BigInteger | 主键，自动生成 |
| name | CharField(100) | 订阅名称（如"中国法定节假日"） |
| slug | SlugField | 唯一标识（如"china-holidays"），URL友好 |
| description | TextField | 描述信息 |
| color | CharField(7) | 显示颜色（十六进制，如"#FF6B6B"） |
| icon | CharField(10) | 图标emoji（如"🎉"） |
| is_public | BooleanField | 是否公开订阅 |
| is_active | BooleanField | 是否激活（管理员可以禁用） |
| event_count | IntegerField | 事件数量（统计用） |
| subscriber_count | IntegerField | 订阅者数量（统计用） |
| created_at | DateTimeField | 创建时间 |
| updated_at | DateTimeField | 更新时间 |

**简单理解**：这是"订阅源列表"，记录着所有可以订阅的日历源。

**字段详解**：

- **id**：订阅的唯一编号
- **name**：订阅的名称，用于界面显示
- **slug**：唯一标识，用于API查询（如"china-holidays"），URL友好
- **description**：订阅的描述信息
- **color**：显示颜色，用于在日历上区分
- **icon**：图标emoji
- **is_public**：是否公开，公开的订阅任何人都可以订阅
- **is_active**：是否激活，管理员可以禁用某些订阅源
- **event_count**：这个订阅源有多少个日程事件
- **subscriber_count**：有多少用户订阅了这个源
- **created_at/updated_at**：创建和更新时间

**数据示例**：

```python
Subscription(
    id = 1,
    name = "中国法定节假日",
    slug = "china-holidays",
    is_public = True,
    is_active = True,
    event_count = 11,
    subscriber_count = 1000
)
```

### 3️⃣ Event 实体（日程表）

**作用**：存储所有用户的日程事件

**实体结构**：

| 字段名 | 类型 | 说明 |
|--------|------|------|
| id | BigInteger | 主键，自动生成 |
| title | CharField(200) | 日程标题，必填 |
| description | TextField | 日程描述 |
| start_time | DateTimeField | 开始时间，必填 |
| end_time | DateTimeField | 结束时间，可选 |
| reminder_minutes | IntegerField | 提前提醒分钟数 |
| user_id | BigInteger? | 用户ID，外键，可空（null=公开订阅的日程） |
| subscription_id | BigInteger? | 订阅ID，外键，可空（null=用户创建的日程） |
| location_name | CharField(200) | 地点名称 |
| latitude | FloatField | 纬度 |
| longitude | FloatField | 经度 |
| created_at | DateTimeField | 创建时间 |
| updated_at | DateTimeField | 更新时间 |

**简单理解**：这是"日程本"，记录着所有用户的日程数据。

**字段详解**：

- **id**：日程的唯一编号
- **title**：日程标题（如"团队会议"、"春节"）
- **description**：日程描述
- **start_time**：开始时间（DateTime格式）
- **end_time**：结束时间，可选（如会议从14:00到16:00）
- **reminder_minutes**：提前提醒分钟数
- **user_id**：用户ID，标识是谁创建的日程（null表示公开订阅的日程）
- **subscription_id**：订阅ID，标识日程来自哪个订阅源（null表示用户创建的日程）
- **location_name/latitude/longitude**：地点信息
- **created_at/updated_at**：创建和更新时间

**数据示例**：

```python
# 用户创建的日程
Event(
    id = 1,
    title = "团队会议",
    start_time = "2024-01-10 14:00:00",
    user_id = 1,  # 用户ID=1创建的
    subscription_id = None  # 用户创建的，不是订阅的
)

# 订阅的日程
Event(
    id = 2,
    title = "春节",
    start_time = "2024-01-01 00:00:00",
    user_id = None,  # 公开的，不是某个用户创建的
    subscription_id = 1  # 来自订阅ID=1的订阅源
)
```

## 🔗 实体关系（箭头表示关联）

### 关系一：User 与 Event（一对多）

```
User (1) ──────── (N) Event
用户                    多个日程
```

**关系说明**：

- **一个用户**可以创建**多个日程**（一对多关系）
- **一个日程**只能属于**一个用户**（多对一关系）
- 使用 `user_id` 字段关联

**简单理解**：
- 就像一个人可以写多篇日记
- 每篇日记通过 `user_id` 知道是谁写的
- 如果 `user_id` 是 null，说明这是公开订阅的日程（不是用户创建的）

**关系示例**：

```
用户（ID=1）：张三
  ├── 日程1：团队会议（user_id = 1）
  ├── 日程2：约会（user_id = 1）
  └── 日程3：提醒（user_id = 1）

用户（ID=2）：李四
  ├── 日程1：出差（user_id = 2）
  └── 日程2：会议（user_id = 2）

公开日程（user_id = None）
  ├── 日程1：春节（user_id = None，subscription_id = 1）
  ├── 日程2：元旦（user_id = None，subscription_id = 1）
  └── ...（所有用户都能看到）
```

### 关系二：Subscription 与 Event（一对多）

```
Subscription (1) ──────── (N) Event
订阅源                    多个日程
```

**关系说明**：

- **一个订阅源**可以有**多个日程**（一对多关系）
- **一个日程**只能属于**一个订阅源**（多对一关系）
- 使用 `subscription_id` 字段关联

**简单理解**：
- 就像一个公众号可以发多篇文章
- 每篇文章通过 `subscription_id` 知道它来自哪个公众号
- 如果 `subscription_id` 是 null，说明这是用户自己创建的日程

**关系示例**：

```
订阅源（ID=1）：中国法定节假日
  ├── 日程1：元旦（subscription_id = 1）
  ├── 日程2：春节（subscription_id = 1）
  ├── 日程3：清明节（subscription_id = 1）
  └── ...（共11个法定节假日）

订阅源（ID=2）：世界纪念日
  ├── 日程1：世界和平日（subscription_id = 2）
  ├── 日程2：世界环境日（subscription_id = 2）
  └── ...（共365个纪念日）

用户创建的日程（subscription_id = None）
  ├── 日程1：团队会议（subscription_id = None）
  ├── 日程2：约会（subscription_id = None）
  └── ...（用户自己创建的）
```

### 关系三：Event 的双重关联

**Event 同时关联 User 和 Subscription**：

```
Event
├── user_id → User（谁创建的）
└── subscription_id → Subscription（来自哪个订阅源）
```

**关系说明**：

- Event可以关联User（表示谁创建的）
- Event可以关联Subscription（表示来自哪个订阅源）
- 这两个关系是**互斥的**：
  - 如果 `user_id` 有值，`subscription_id` 通常是 null（用户创建的）
  - 如果 `subscription_id` 有值，`user_id` 通常是 null（订阅的）

**简单理解**：
- 就像一本书，可能是一个人写的（user_id），也可能是出版社出版的（subscription_id）
- 两者可以同时存在，但通常只有一个

**数据示例**：

```python
# 用户创建的日程
Event(
    user_id = 1,  # 用户创建的
    subscription_id = None  # 不是订阅的
)

# 订阅的日程
Event(
    user_id = None,  # 不是用户创建的
    subscription_id = 1  # 来自订阅源
)

# 理论上可以同时存在（但一般不这样设计）
Event(
    user_id = 1,  # 用户创建的
    subscription_id = 1  # 同时又来自订阅源（特殊情况）
)
```

## 💡 举个例子理解ER图

**场景一**：用户张三创建了一个日程

1. 张三登录系统（User表中有记录，id = 1）
2. 张三点击"添加日程"，创建了一个日程
3. 系统创建一个Event记录：
   - title = "团队会议"
   - user_id = 1（标识是张三创建的）
   - subscription_id = None（不是订阅的）
4. 这个日程只属于张三，其他用户看不到

**简单理解**：就像写日记，你写的日记只属于你，别人看不到。

**场景二**：所有用户订阅"中国法定节假日"

1. 后端有一个Subscription记录（id = 1，slug = "china-holidays"）
2. 后端有多个Event记录，都属于这个订阅源：
   - 元旦（subscription_id = 1）
   - 春节（subscription_id = 1）
   - ...（共11个）
3. 所有用户订阅后，都能看到这些日程
4. 这些日程的user_id都是None（不是某个用户创建的）

**简单理解**：就像订阅报纸，所有人都能看到报纸上的文章，但文章不是某个读者写的。

**场景三**：用户订阅后，日程如何显示

1. 用户订阅"中国法定节假日"（Subscription，id = 1）
2. 系统查询所有subscription_id = 1的Event
3. 返回给用户：元旦、春节、清明节等11个日程
4. 用户在自己的日历上看到这些日程

**简单理解**：就像订阅公众号，你订阅后，就能看到所有历史文章。

## 🎯 为什么要设计这些关系？

### User 与 Event 的关系

1. **用户隔离**：
   - 每个用户的日程是独立的
   - 通过user_id区分是谁创建的

2. **权限控制**：
   - 用户只能看到和修改自己的日程
   - 公开订阅的日程所有用户都能看到

### Subscription 与 Event 的关系

1. **订阅管理**：
   - 通过订阅源批量管理日程
   - 取消订阅时，可以批量删除相关日程

2. **数据共享**：
   - 公开订阅的日程，所有用户都能看到
   - 减少重复数据存储

### Event 的双重关联

1. **灵活区分**：
   - 可以区分用户创建的日程和订阅的日程
   - 支持不同的权限管理

2. **数据统计**：
   - 可以统计每个用户创建了多少日程
   - 可以统计每个订阅源有多少日程

## 📊 关系图的特点

### 优点

- **结构清晰**：三个实体职责明确
- **关系明确**：通过外键关联，关系清晰
- **易于扩展**：可以轻松添加新功能

### 注意事项

- **外键约束**：user_id和subscription_id必须对应存在的记录
- **删除策略**：删除用户时，需要处理用户的日程（保留或删除）
- **空值处理**：user_id和subscription_id可以为null（根据业务逻辑）

## 📝 总结

这个图展示了后端数据库的结构：

- **User 实体**：用户表，存储所有用户信息
- **Subscription 实体**：订阅表，存储订阅的日历源
- **Event 实体**：日程表，存储所有日程数据

**关系**：
- User (1) ──── (N) Event（一个用户创建多个日程）
- Subscription (1) ──── (N) Event（一个订阅源包含多个日程）

就像图书馆系统：
- **User** = 读者（借书的人）
- **Subscription** = 图书分类（如"文学类"、"科技类"）
- **Event** = 书籍（每本书都属于一个分类，可以被读者借阅）

它们共同构建了后端的数据库结构，既支持用户创建日程，也支持订阅共享日历，实现了灵活的数据管理！

